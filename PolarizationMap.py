#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Tue Apr 18 14:05:59 2023@author: reidmarkland"""#import osimport hyperspy.api as hsimport matplotlib.pyplot as pltimport temul.api as tmlimport atomap.api as amfrom temul.dummy_data import get_polarisation_dummy_dataset  # No need for dummy data importimport atomapimport numpy as np# Load the image#/Users/dizhang/Desktop/Polarization map fitting/Polarization map fitting/IFFT of Non-regid alignment 002-2_bw copy.pngpath = r'/Users/dizhang/Desktop/Polarization map fitting/Polarization map fitting'file = r'IFFT of Non-regid alignment 002-2_bw copy.png'image = hs.load(os.path.join(path, file))# Convert RGB to grayscale# Using weighted average to account for human perception (standard formula)# grayscale_data = 0.2989 * image.data['R'] + 0.5870 * image.data['G'] + 0.1140 * image.data['B']## # Convert to float32# grayscale_data = grayscale_data.astype(np.float32)## # Replace the image data with the grayscale data# image.data = grayscale_data# Resize the image to desired dimensionsimage_resized = image.rebin((775, 775))# Visualize and filter the imagetml.visualise_dg_filter(image_resized)filtered_image = tml.double_gaussian_fft_filter(image_resized, 40, 200)# Shift all values to be positivemin_val = filtered_image.data.min()if min_val < 0:    filtered_image.data -= min_val# Plot the imagesimage_resized.plot()filtered_image.plot()plt.show()image = filtered_imagedef GetLatticeA(image, separation):    atom_positions_A = am.get_atom_positions(image, separation)    sublattice_A = am.Sublattice(atom_positions_A, image = image.data)    sublattice_A.find_nearest_neighbors()    sublattice_A.refine_atom_positions_using_center_of_mass()    sublattice_A.refine_atom_positions_using_2d_gaussian()    sublattice_A.construct_zone_axes()    sublattice_A_image_float64 = sublattice_A.image.astype(np.float64)    mat_noA = atomap.tools.remove_atoms_from_image_using_2d_gaussian(sublattice_A_image_float64, sublattice_A)    mat_noA = mat_noA.astype(np.uint8)    image_noA = hs.signals.BaseSignal(mat_noA)    return sublattice_A, image_noAimport numpy as npimport atomap.toolsdef GetLatticeB(image_noA, separation):    atom_positions_B = am.get_atom_positions(image_noA, separation = separation)    sublattice_B = am.Sublattice(atom_positions_B, image = image_noA.data, color='blue')    sublattice_B.construct_zone_axes()    sublattice_B.refine_atom_positions_using_center_of_mass()    sublattice_B.refine_atom_positions_using_2d_gaussian()    sublattice_B_image_float64 = sublattice_B.image.astype(np.float64)    mat_bkgnd = atomap.tools.remove_atoms_from_image_using_2d_gaussian(sublattice_B_image_float64, sublattice_B)    mat_bkgnd = mat_bkgnd.astype(np.uint8)    image_bkgnd = hs.signals.BaseSignal(mat_bkgnd)    return sublattice_B, image_bkgnd## def PolarizationMap(atom_lattice, image):#     sublattice_A = atom_lattice.sublattice_list[0]#     sublattice_B = atom_lattice.sublattice_list[1]##     za0, za1 = sublattice_A.zones_axis_average_distances[0:2]#     polarization = sublattice_A.get_polarization_from_second_sublattice(za0, za1, sublattice_B, color = 'cyan')#     vector_list = polarization.metadata.vector_list##     x, y = [i[0] for i in vector_list], [i[1] for i in vector_list]#     u, v = [i[2] for i in vector_list], [i[3] for i in vector_list]#     x, y, u, v = np.asarray(x), np.asarray(y), np.asarray(u), np.asarray(v)##     sampling = image.axes_manager[-1].scale#     units = image.axes_manager[-1].units#     save = "slide8_Pol"#     plot_style = 'colormap'#     overlay = True  # the vectors will be plotted on the image#     unit_vector = True  # formerly called normalise#     vector_rep = 'angle'  # 'magnitude' or 'angle'#     degrees = True  # Set to True for degrees, False for radians#     angle_offset = None#     title = ""#     # color = 'yellow'  # may be ignored depending on the plot_style#     cmap = 'hsv'  # may be ignored depending on the plot_style#     alpha = 1.0  # transparency of image or vectors, depending on plot_style#     image_cmap = 'gray'#     ticks = None#     scalebar = False#     monitor_dpi = 50  # set to ~200 to make too-large images a bit smaller#     no_axis_info = True#     invert_y_axis = True#     antialiased = False  # relevant for the contour mapping#     levels = 20  # relevant for the contour mapping#     remove_vectors = False#     scale = 0.015  # set to 0.001-0.01 to change arrow size#     width = 0.008  # set to ~0.005 for chunky (thicker) arrows#     minshaft = 2#     minlength = 1.5#     headwidth = 2.5#     headlength = 2.5#     headaxislength = 2#     quiver_units = 'width'#     pivot = 'middle'#     angles = 'xy'#     scale_units = 'xy'###     ax_vectors = tml.plot_polarisation_vectors(#         x, y, u, v, image.data, sampling=sampling, units=units,#         plot_style=plot_style, overlay=overlay, unit_vector=unit_vector,#         vector_rep=vector_rep, degrees=degrees, angle_offset=angle_offset,#         save=save, title=title  , cmap=cmap, alpha=alpha,#         image_cmap=image_cmap, monitor_dpi=monitor_dpi,#         no_axis_info=no_axis_info, invert_y_axis=invert_y_axis, ticks=ticks,#         scalebar=scalebar, antialiased=antialiased, levels=levels,#         remove_vectors=remove_vectors, quiver_units=quiver_units, pivot=pivot,#         angles=angles, scale_units=scale_units, scale=scale, headwidth=headwidth,#         headlength=headlength, headaxislength=headaxislength, width=width,#         minshaft=minshaft, minlength=minlength)##     return ax_vectors## peaksA = am.get_feature_separation(image, separation_range=(25,30))# peaksA.plot()# plt.show()separation = 10 # parameter 1. set based on lower limit of good fit from peaks^, 38 is being used for 2-2 imagesublattice_A, image_noA = GetLatticeA(image, separation)sublattice_A.plot()sublattice_A.plot_planes()# plt.show()zone_axis_001 = sublattice_A.zones_axis_average_distances[3] #parameter 2print(sublattice_A.zones_axis_average_distances[0]) #bad fit, lil better than [1]print(sublattice_A.zones_axis_average_distances[1]) #bad fittingprint(sublattice_A.zones_axis_average_distances[2]) #works well: Using this one for 2-2 imageprint(sublattice_A.zones_axis_average_distances[3]) #works wellprint(sublattice_A.zones_axis_average_distances)B_positions = sublattice_A.find_missing_atoms_from_zone_vector(zone_axis_001, vector_fraction= 0.5)sublattice_A_image_float64 = sublattice_A.image.astype(np.float64)mat_noA = atomap.tools.remove_atoms_from_image_using_2d_gaussian(sublattice_A_image_float64, sublattice_A, percent_to_nn= 0.35) #0.3 used for 2-2, .75 parameter 3mat_noA = mat_noA.astype(np.uint8)image_noA = hs.signals.BaseSignal(mat_noA)image_noA.plot()plt.show()sublattice_B = am.Sublattice(B_positions, mat_noA, color='blue')sublattice_B.construct_zone_axes()sublattice_B.refine_atom_positions_using_center_of_mass()sublattice_B.refine_atom_positions_using_2d_gaussian()atom_lattice = am.Atom_Lattice(image=image.data, name='test', sublattice_list=[sublattice_A, sublattice_B], fix_negative_values=True)atom_lattice.plot()# plt.show()atom_lattice = am.Atom_Lattice(image = image, name = 'test', sublattice_list=[sublattice_A, sublattice_B], fix_negative_values=True)atom_lattice.plot()sublattice_A.construct_zone_axes()za0, za1 = sublattice_A.zones_axis_average_distances[0:2] #parameter 4 (uncommon changed)s_p = sublattice_A.get_polarization_from_second_sublattice(za0, za1, sublattice_B, color='blue')vector_list = s_p.metadata.vector_listx, y = [i[0] for i in vector_list], [i[1] for i in vector_list]u, v = [i[2] for i in vector_list], [i[3] for i in vector_list]print(f"U vector range: {np.min(u)} to {np.max(u)}")print(f"V vector range: {np.min(v)} to {np.max(v)}")# Normalize or scale vectors if necessary# magnitude = np.sqrt(np.array(u)**2 + np.array(v)**2)# u_normalized = np.array(u) / magnitude# v_normalized = np.array(v) / magnitude# # Plotting# ax = tml.plot_polarisation_vectors(x, y, u_normalized, v_normalized, image=image_resized,#                                    plot_style="polar_colorwheel",#                                    unit_vector=False, overlay=True,#                                    save=None, monitor_dpi=100)# ax.invert_yaxis()ax = tml.plot_polarisation_vectors(x, y, u, v, image=image_resized,                                   plot_style="polar_colorwheel",                                   unit_vector=False, overlay=True,                                   save=None, monitor_dpi=100)tml.plot_polarisation_vectors(x, y, u, v, image=filtered_image, unit_vector=False, save=None, plot_style='vector', color='r', overlay=True, monitor_dpi=50)#headwidth= 6, headlength=10, headaxislength=9, minshaft=2, minlength=2# This plot may show the effect of the second dimension more clearly.# Example taken from Matplotlib's Quiver documentation.import numpy as npX, Y = np.meshgrid(np.arange(0, 2 * np.pi, .2), np.arange(0, 2 * np.pi, .2))image_temp = np.ones_like(X)U = np.reshape(np.cos(X), 1024)V = np.reshape(np.sin(Y), 1024)X, Y = np.reshape(X, 1024), np.reshape(Y, 1024)ax = tml.plot_polarisation_vectors(X, Y, U, -V, image=image_temp,plot_style="polar_colorwheel",overlay=False, invert_y_axis=False, save=None, monitor_dpi=None)ax.invert_yaxis()plt.show()